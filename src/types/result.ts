export class Failure {
  brief: string;
  detail?: string;
  stack: string;

  constructor(
    brief: string,
    detail?: string,
    external_constructor?: (new (...arg: any[]) => any) | ((...arg: any[]) => any),
  ) {
    this.brief = brief;
    this.detail = detail;
    this.stack = "";
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, external_constructor ?? Failure);
    } else {
      this.stack = new Error("dummy").stack ?? "";
    }
  }

  toString(): string {
    const components = [this.brief];
    if (this.detail) {
      components.push(`${this.detail}`);
    }
    return components.join(": ");
  }
}
export class Result<Expected> {
  #result?: Expected;
  #failure?: Failure;

  private constructor(content: { result?: Expected; failure?: Failure }) {
    this.#result = content.result;
    this.#failure = content.failure;
  }

  static ok<Expected>(result: Expected): Result<Expected> {
    return new Result<Expected>({ result });
  }

  static error<Expected>(brief: string, detail?: string): Result<Expected> {
    return new Result<Expected>({ failure: new Failure(brief, detail, Result.error) });
  }

  private static immediate_error<Expected>(failure: Failure): Result<Expected> {
    return new Result<Expected>({ failure });
  }

  // place Promise<...> out of Result<...>
  //  if this is an instance of Result<Promise<T>>, the result will be Promise<Result<T>>
  //  otherwise, this is returned as-is
  //  note that this method does not handle nested cases (for example Result<Promise<Promise<T>>>)
  shift_promise(): Expected extends Promise<infer T> ? Promise<Result<T>> : Result<Expected> {
    if (this.#failure !== undefined) {
      return this.erase_type();
    }
    if (this.#result instanceof Promise) {
      const result = this.#result;
      const new_result = new Promise(resolve => {
        result.then(
          data => {
            resolve(Result.ok(data));
          },
          error => {
            resolve(
              Result.error(
                "Failure in Promise",
                `This is generated by Result.shift_promise. Here is the original error: ${String(error)}`,
              ),
            );
          },
        );
      });
      return new_result as any;
    }
    return this.erase_type();
  }

  // flatten Result structure
  // change any Result<Result<T>> into Result<T>
  flatten(): FlattenResult<Result<Expected>> {
    if (this.#failure !== undefined) {
      return this.erase_type();
    }
    if (this.#result instanceof Result) {
      return this.#result.flatten();
    }
    return this.erase_type();
  }

  is_ok(): boolean {
    return this.#failure === undefined;
  }

  is_err(): boolean {
    return this.#failure !== undefined;
  }

  is_ok_and(callback: (value: Expected) => boolean): boolean {
    return this.is_ok() && callback(this.#result!);
  }

  is_err_and(callback: (value: Failure) => boolean): boolean {
    return this.is_err() && callback(this.#failure!);
  }

  unwrap_unchecked(): Expected {
    return this.#result!;
  }

  unwrap_or_else(callback: (failure: Failure) => Expected): Expected {
    if (this.#failure !== undefined) {
      return callback(this.#failure!);
    }
    return this.#result!;
  }

  unwrap(): Expected {
    return this.unwrap_or_else(() => {
      throw new Error("unwrap Result in failed state");
    });
  }

  unwrap_or(fallback: Expected): Expected {
    return this.unwrap_or_else(() => fallback);
  }

  unwrap_error_unchecked(): Failure {
    return this.#failure!;
  }

  unwrap_error(): Failure {
    if (this.#failure === undefined) {
      throw new Error("unwrap_error Result in succeed state");
    }
    return this.#failure;
  }

  map<R>(callback: (value: Expected) => R): R extends Result<infer U> ? Result<U> : Result<R> {
    if (this.#failure !== undefined) {
      return this as any;
    }
    const new_result = callback(this.#result!);
    if (new_result instanceof Result) {
      return new_result as any;
    }
    return Result.ok<R>(new_result) as any;
  }

  map_error(callback: (failure: Failure) => Failure | undefined): Result<Expected> {
    if (this.#failure === undefined) {
      return this;
    }
    const new_failure = callback(this.#failure);
    if (new_failure === undefined) {
      return this;
    }
    return Result.immediate_error<Expected>(new_failure);
  }

  inspect(callback: (value: Expected) => void): void {
    callback(this.unwrap());
  }

  inspect_error(callback: (failure: Failure) => void): void {
    callback(this.unwrap_error());
  }

  // in case that current instance is in failed state, its type can be safely erased since the expected type
  //  never affected instances in failed state
  erase_type(): any {
    return this;
  }
}

type FlattenResult<T> = T extends Result<infer U> ? (U extends Result<unknown> ? FlattenResult<U> : T) : T;
